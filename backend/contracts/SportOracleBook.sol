// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {
  FHE,
  ebool,
  euint32,
  euint64,
  externalEuint32,
  externalEuint64
} from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title SportOracleBook
/// @notice Fully homomorphic encrypted betting exchange for sports markets.
/// @dev Utilises Zama fhEVM primitives to keep bettors' selections and stakes private on-chain.
contract SportOracleBook is AccessControl, SepoliaConfig, ReentrancyGuard {
  bytes32 public constant MARKET_MAKER_ROLE = keccak256("MARKET_MAKER_ROLE");
  bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
  bytes32 public constant GATEWAY_ROLE = keccak256("GATEWAY_ROLE");

  /// @notice Scaling factor used to avoid precision loss during encrypted division.
  uint64 private constant SCALE = 1_000_000;

  /// @notice Upper bound to avoid pathological loops on encrypted outcome matching.
  uint8 private constant MAX_OUTCOMES = 16;

  struct Market {
    uint8 outcomeCount;
    uint256 startTime;
    uint256 lockTime;
    bool settled;
    uint8 winningOutcome;
    bool decryptionPending;
    euint64 encryptedPool;
    euint64[] encryptedOutcomeTotals;
    uint64 payoutRatioPlain;
  }

  struct BetTicket {
    address bettor;
    uint256 marketId;
    externalEuint32 encryptedOutcome;
    externalEuint64 encryptedStake;
    bytes32 commitment;
    uint256 escrowedValue;
    bool claimed;
  }

  struct MarketView {
    uint256 marketId;
    uint8 outcomeCount;
    uint256 startTime;
    uint256 lockTime;
    bool settled;
    uint8 winningOutcome;
    uint256 escrowBalance;
    uint64 payoutRatio;
    bool decryptionPending;
  }

  struct TicketView {
    uint256 ticketId;
    address bettor;
    uint256 marketId;
    bytes32 commitment;
    uint256 escrowedValue;
    bool claimed;
  }

  /// @notice Tracks market information by external identifier.
  mapping(uint256 => Market) private markets;

  /// @notice Stores the list of market identifiers for iteration.
  uint256[] private marketIds;

  /// @notice Records fully encrypted bet slips keyed by autogenerated ticket id.
  mapping(uint256 => BetTicket) private tickets;

  /// @notice Guards repeated re-use of the same encrypted payload commitment.
  mapping(bytes32 => bool) private commitmentRegistry;

  /// @notice Associates asynchronous gateway callbacks to ticket identifiers.
  mapping(uint256 => uint256) private requestToTicket;

  /// @notice Associates asynchronous gateway callbacks to bettors.
  mapping(uint256 => address) private requestToBettor;

  /// @notice Associates payout ratio decryption requests to market ids.
  mapping(uint256 => uint256) private requestToMarket;

  /// @notice Tracks the locked escrow per market for accounting.
  mapping(uint256 => uint256) private marketEscrow;

  /// @notice Incremental ticket sequence to provide stable identifiers.
  uint256 private nextTicketId = 1;

  event MarketCreated(uint256 indexed marketId, uint8 outcomeCount, uint256 startTime, uint256 lockTime);
  event BetPlaced(
    uint256 indexed marketId,
    uint256 indexed ticketId,
    address indexed bettor,
    bytes32 commitment,
    uint256 escrowedValue
  );
  event MarketSettled(uint256 indexed marketId, uint8 winningOutcome, uint256 requestId);
  event PayoutRequested(uint256 indexed ticketId, uint256 indexed requestId);
  event PayoutClaimed(uint256 indexed ticketId, address indexed bettor, uint64 decryptedAmount);

  error MarketAlreadyExists(uint256 marketId);
  error InvalidOutcomeCount();
  error InvalidSchedule();
  error MarketNotFound(uint256 marketId);
  error MarketLocked(uint256 marketId);
  error CommitmentAlreadyUsed(bytes32 commitment);
  error TicketAlreadyClaimed(uint256 ticketId);
  error UnauthorizedTicketOwner(uint256 ticketId, address caller);
  error MarketNotSettled(uint256 marketId);
  error WinningOutcomeOutOfBounds(uint8 winningOutcome);
  error SettlementAlreadyProcessed(uint256 marketId);
  error UnknownDecryptionRequest(uint256 requestId);
  error MaximumOutcomesExceeded(uint8 outcomeCount);
  error NoEscrow();
  error TicketNotFound(uint256 ticketId);

  constructor(address admin, address gateway) {
    _grantRole(DEFAULT_ADMIN_ROLE, admin);
    _grantRole(MARKET_MAKER_ROLE, admin);
    _grantRole(ORACLE_ROLE, admin);

    if (gateway != address(0)) {
      _grantRole(GATEWAY_ROLE, gateway);
    }
  }

  /// @notice Creates a brand new encrypted market.
  /// @dev Initializes encrypted accumulators at zero to honour FHE permissioning.
  function createMarket(
    uint256 marketId,
    uint8 outcomeCount,
    uint256 startTime,
    uint256 lockTime
  ) external onlyRole(MARKET_MAKER_ROLE) {
    if (markets[marketId].outcomeCount != 0) {
      revert MarketAlreadyExists(marketId);
    }
    if (outcomeCount < 2) {
      revert InvalidOutcomeCount();
    }
    if (outcomeCount > MAX_OUTCOMES) {
      revert MaximumOutcomesExceeded(outcomeCount);
    }
    if (startTime >= lockTime) {
      revert InvalidSchedule();
    }

    Market storage market = markets[marketId];
    market.outcomeCount = outcomeCount;
    market.startTime = startTime;
    market.lockTime = lockTime;
    market.encryptedPool = FHE.allowThis(FHE.asEuint64(0));
    market.payoutRatioPlain = 0;

    for (uint8 i = 0; i < outcomeCount; i++) {
      market.encryptedOutcomeTotals.push(FHE.allowThis(FHE.asEuint64(0)));
    }

    marketIds.push(marketId);

    emit MarketCreated(marketId, outcomeCount, startTime, lockTime);
  }

  /// @notice Places an encrypted bet for the caller on the selected market.
  /// @param marketId The target market identifier.
  /// @param encryptedOutcome Encrypted outcome handle provided by the frontend.
  /// @param encryptedStake Encrypted stake handle provided by the frontend.
  /// @param proof Groth16 proof ensuring payload correctness.
  /// @param commitment Unique commitment digest to prevent replayed ciphertexts.
  function placeBet(
    uint256 marketId,
    externalEuint32 encryptedOutcome,
    externalEuint64 encryptedStake,
    bytes calldata proof,
    bytes32 commitment
  ) external payable nonReentrant returns (uint256 ticketId) {
    Market storage market = markets[marketId];
    if (market.outcomeCount == 0) {
      revert MarketNotFound(marketId);
    }
    if (block.timestamp >= market.lockTime) {
      revert MarketLocked(marketId);
    }
    if (commitmentRegistry[commitment]) {
      revert CommitmentAlreadyUsed(commitment);
    }
    if (msg.value == 0) {
      revert NoEscrow();
    }

    // Verify ciphertexts and import them into contract memory space.
    euint32 outcome = FHE.fromExternal(encryptedOutcome, proof);
    euint64 stake = FHE.fromExternal(encryptedStake, proof);
    FHE.allowThis(outcome);
    FHE.allowThis(stake);

    // Update encrypted global pool.
    market.encryptedPool = FHE.add(market.encryptedPool, stake);
    FHE.allowThis(market.encryptedPool);

    // Update encrypted total per outcome using conditional selection.
    for (uint8 i = 0; i < market.outcomeCount; i++) {
      euint64 additionalStake = FHE.select(
        FHE.eq(outcome, FHE.asEuint32(uint32(i))),
        stake,
        FHE.asEuint64(0)
      );
      market.encryptedOutcomeTotals[i] = FHE.add(market.encryptedOutcomeTotals[i], additionalStake);
      FHE.allowThis(market.encryptedOutcomeTotals[i]);
    }

    marketEscrow[marketId] += msg.value;

    ticketId = nextTicketId++;
    tickets[ticketId] = BetTicket({
      bettor: msg.sender,
      marketId: marketId,
      encryptedOutcome: encryptedOutcome,
      encryptedStake: encryptedStake,
      commitment: commitment,
      escrowedValue: msg.value,
      claimed: false
    });

    commitmentRegistry[commitment] = true;

    emit BetPlaced(marketId, ticketId, msg.sender, commitment, msg.value);
  }

  /// @notice Oracle publishes the winning outcome and triggers payout ratio computation.
  function settleMarket(uint256 marketId, uint8 winningOutcome) external onlyRole(ORACLE_ROLE) {
    Market storage market = markets[marketId];
    if (market.outcomeCount == 0) {
      revert MarketNotFound(marketId);
    }
    if (market.settled) {
      revert SettlementAlreadyProcessed(marketId);
    }
    if (winningOutcome >= market.outcomeCount) {
      revert WinningOutcomeOutOfBounds(winningOutcome);
    }

    market.settled = true;
    market.winningOutcome = winningOutcome;

    market.payoutRatioPlain = 0;

    // Request decrypted pool and winning total to compute payout ratio off-chain.
    bytes32[] memory handles = new bytes32[](2);
    handles[0] = FHE.toBytes32(market.encryptedPool);
    handles[1] = FHE.toBytes32(market.encryptedOutcomeTotals[winningOutcome]);
    uint256 requestId = FHE.requestDecryption(handles, this.onSettlementDecrypted.selector);
    market.decryptionPending = true;
    requestToMarket[requestId] = marketId;

    emit MarketSettled(marketId, winningOutcome, requestId);
  }

  /// @notice Redeems the encrypted ticket for a decrypted payout amount.
  function claimPayout(uint256 ticketId, bytes calldata inputProof) external nonReentrant {
    BetTicket storage ticket = tickets[ticketId];
    if (ticket.bettor == address(0)) {
      revert MarketNotFound(ticket.marketId);
    }
    if (ticket.claimed) {
      revert TicketAlreadyClaimed(ticketId);
    }
    if (ticket.bettor != msg.sender) {
      revert UnauthorizedTicketOwner(ticketId, msg.sender);
    }

    Market storage market = markets[ticket.marketId];
    if (!market.settled) {
      revert MarketNotSettled(ticket.marketId);
    }

    euint32 outcome = FHE.fromExternal(ticket.encryptedOutcome, inputProof);
    FHE.allowThis(outcome);

    ebool isWinner = FHE.eq(outcome, FHE.asEuint32(uint32(market.winningOutcome)));

    euint64 stake = FHE.fromExternal(ticket.encryptedStake, inputProof);
    FHE.allowThis(stake);

    // payout = (stake * payoutRatio) / SCALE
    euint64 numerator = FHE.mul(stake, market.payoutRatioPlain);
    euint64 rawPayout = FHE.div(numerator, SCALE);
    FHE.allowThis(rawPayout);

    euint64 encryptedPayout = FHE.select(isWinner, rawPayout, FHE.asEuint64(0));
    FHE.allowThis(encryptedPayout);

    bytes32[] memory handles = new bytes32[](1);
    handles[0] = FHE.toBytes32(encryptedPayout);
    uint256 requestId = FHE.requestDecryption(handles, this.onPayoutDecrypted.selector);

    requestToTicket[requestId] = ticketId;
    requestToBettor[requestId] = msg.sender;
    ticket.claimed = true;

    emit PayoutRequested(ticketId, requestId);
  }

  /// @notice Gateway callback publishing decrypted pool and winner totals.
  function onSettlementDecrypted(
    uint256 requestId,
    bytes calldata cleartexts,
    bytes calldata decryptionProof
  ) external onlyRole(GATEWAY_ROLE) {
    FHE.checkSignatures(requestId, cleartexts, decryptionProof);
    uint256 marketId = requestToMarket[requestId];
    if (marketId == 0 && requestId != 0) {
      revert UnknownDecryptionRequest(requestId);
    }

    Market storage market = markets[marketId];
    market.decryptionPending = false;
    delete requestToMarket[requestId];

    (uint64 poolPlain, uint64 winnerPlain) = abi.decode(cleartexts, (uint64, uint64));
    if (winnerPlain == 0) {
      market.payoutRatioPlain = 0;
    } else {
      uint256 scaled = uint256(poolPlain) * SCALE;
      market.payoutRatioPlain = uint64(scaled / winnerPlain);
    }
  }

  /// @notice Gateway callback delivering decrypted payout amounts to winners.
  function onPayoutDecrypted(
    uint256 requestId,
    bytes calldata cleartexts,
    bytes calldata decryptionProof
  ) external onlyRole(GATEWAY_ROLE) nonReentrant {
    FHE.checkSignatures(requestId, cleartexts, decryptionProof);
    uint256 ticketId = requestToTicket[requestId];
    address bettor = requestToBettor[requestId];
    if (ticketId == 0 || bettor == address(0)) {
      revert UnknownDecryptionRequest(requestId);
    }

    BetTicket storage ticket = tickets[ticketId];
    uint256 marketId = ticket.marketId;

    delete requestToTicket[requestId];
    delete requestToBettor[requestId];

    uint64 decryptedAmount = abi.decode(cleartexts, (uint64));
    if (decryptedAmount > 0) {
      if (marketEscrow[marketId] >= decryptedAmount) {
        marketEscrow[marketId] -= decryptedAmount;
      }
      (bool success, ) = bettor.call{ value: decryptedAmount }("");
      require(success, "SportOracleBook: payout transfer failed");
    }

    emit PayoutClaimed(ticketId, bettor, decryptedAmount);
  }

  /// @notice Returns view information for a market without leaking encrypted totals.
  function getMarket(uint256 marketId) external view returns (MarketView memory) {
    Market storage market = markets[marketId];
    if (market.outcomeCount == 0) {
      revert MarketNotFound(marketId);
    }

    return
      MarketView({
        marketId: marketId,
        outcomeCount: market.outcomeCount,
        startTime: market.startTime,
        lockTime: market.lockTime,
        settled: market.settled,
        winningOutcome: market.winningOutcome,
        escrowBalance: marketEscrow[marketId],
        payoutRatio: market.payoutRatioPlain,
        decryptionPending: market.decryptionPending
      });
  }

  /// @notice Returns a light-weight view of a specific encrypted ticket.
  function getTicket(uint256 ticketId) external view returns (TicketView memory) {
    BetTicket storage ticket = tickets[ticketId];
    if (ticket.bettor == address(0)) {
      revert TicketNotFound(ticketId);
    }

    return
      TicketView({
        ticketId: ticketId,
        bettor: ticket.bettor,
        marketId: ticket.marketId,
        commitment: ticket.commitment,
        escrowedValue: ticket.escrowedValue,
        claimed: ticket.claimed
      });
  }

  /// @notice Indicates whether the provided commitment digest has been consumed.
  function isCommitmentUsed(bytes32 commitment) external view returns (bool) {
    return commitmentRegistry[commitment];
  }

  /// @notice Returns the plain payout ratio scaled by SCALE.
  function getPayoutRatio(uint256 marketId) external view returns (uint64) {
    Market storage market = markets[marketId];
    if (market.outcomeCount == 0) {
      revert MarketNotFound(marketId);
    }
    return market.payoutRatioPlain;
  }

  /// @notice Returns all market ids created for client-side discovery.
  function getMarketIds() external view returns (uint256[] memory) {
    return marketIds;
  }

  /// @notice Fallback receiver enabling treasury top ups.
  receive() external payable {}
}
